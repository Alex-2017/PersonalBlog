<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Head First Design Patterns读书笔记 on Alex的博客</title>
    <link>https://wangjc95.com/tags/head-first-design-patterns%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in Head First Design Patterns读书笔记 on Alex的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 28 Mar 2019 21:58:00 +0800</lastBuildDate>
    
	<atom:link href="https://wangjc95.com/tags/head-first-design-patterns%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>状态模式</title>
      <link>https://wangjc95.com/post/12-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 28 Mar 2019 21:58:00 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/12-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.场景介绍 假设我们要为糖果机设置一个控制器,来控制糖果器正常运转.控制流程如下图所示.
这张图可以这么理解:
糖果机在未投币的状态时通过投入25分钱的操作进入已投币的状态.在已投币的状态时,如果退回25分钱就是回到未投币状态,扭动曲柄则是售出糖果状态.但是需要的注意状态与操作的合法性!比如为投币时是不可以进行退回25分钱,扭动曲柄等操作的.</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://wangjc95.com/post/11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 26 Mar 2019 21:51:00 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.场景介绍 基于之前迭代器模式的菜单整合模式下提出了一个新的需求,餐厅要创建一份甜点菜单,并把这个菜单放到餐厅菜单中.
新增的需求让当前的系统到达了一个复杂级别,如果现在不重新设计,就无法容纳未来增加的菜单或子菜单等需求.我们需要某种树形结构,可以容纳菜单,子菜单和菜单项,同时能够确定在每个菜单的各个项之间游走,而且至少要像现在用迭代器一样方便.
2.解决方案 2.</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://wangjc95.com/post/10-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 23 Mar 2019 21:15:15 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/10-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.场景介绍 有两种菜单,分别是DinerMenu和PancakeHouseMenu.将这两种菜单整合,需要一个特定的服务员类Waitress来进行整合和菜单的遍历等功能.
MenuItem.java
package iterator; import lombok.</description>
    </item>
    
    <item>
      <title>模版方法模式</title>
      <link>https://wangjc95.com/post/9-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 20 Mar 2019 22:15:15 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/9-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.场景介绍 假设当前有两种咖啡因饮料,分别是茶和咖啡.
茶的制作方法是:
 把水煮沸 用沸水浸泡茶叶 把茶倒进杯子 加柠檬  咖啡的制作方法:</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://wangjc95.com/post/8-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 20 Mar 2019 22:14:15 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/8-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.场景介绍 家里有一套家庭影院的设备(爆米花机,屏幕,投影仪).每次看电影的时候需要打开爆米花机,开始爆米花,把屏幕放下来,打开投影仪来看电影.结束后要关闭投影仪,收起屏幕,关掉爆米花机.整个过程实在太过于繁琐.
为了改善这个过程,就需要用到外观模式了.通过实现一个提供合理接口的外观类,你可以将复杂的子系统变得容易使用.而且还能够保留原有的子系统接口.
2.应用举例 2.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://wangjc95.com/post/7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 19 Mar 2019 22:46:48 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.场景介绍 假设已有一个软件系统,你希望它能和一个新的厂商类库搭配使用,但是这个新厂商所设计出来的接口,不同于旧厂商的接口.你不想改变现有的代码,这样的话就可以编写一个类,让新厂商接口转接成你所期望的接口.
这个适配器工作起来就如同一个中间人,它将客户所发出的请求转换成厂商类能理解的请求.
2.应用举例 2.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://wangjc95.com/post/6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 19 Mar 2019 22:45:48 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.应用场景 当前有若干个电器,有着不同的方法.需要设计一款遥控器,能够控制所有的电器.并且遥控器便于修改和添加新的电器.
2.命令模式的简单实现 2.1类图 Light,GarageDoor:电器类,灯和车库门.</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://wangjc95.com/post/5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 12 Mar 2019 23:09:48 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.应用场景 在项目中,有些对象我们只需要一个!比如说线程池,缓存,对话框等等.这类对象只能有一个实例,如果制造出多个实例,就会导致很多问题产生.
2.定义 确保一个类只有一个实例,并提供全局访问点.</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://wangjc95.com/post/4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 11 Mar 2019 22:08:48 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>1.简单工厂 1.1应用场景 最近开了一家披萨店,有四种不同口味的披萨.客人只需要输入他需要的口味就可以得到对应的披萨.那么如何用java来设计这样的一个系统呢?
1.2解决方法 最简单的方法就是在一个类中封装一个方法,根据输入的口味,来生成对应的披萨.但是如果商店的披萨品种需要变动时,此类的代码就需要修改.这肯定不是我们所希望的.下面就来使用简单工厂模式来解决这一问题.
1.2.1类图 1.2.2代码 披萨代码:
Pizza.java</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://wangjc95.com/post/3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 28 Feb 2019 21:00:00 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.应用场景 ​ 一点点奶茶店如今在一线及二线城市中大受欢迎,并且在以迅速的速度扩张着.与此同时带来了一个问题,由于订单量暴增,他们的订单管理系统支撑不住了.需要设计一个新的系统,并且能够灵活,快速的改动.
​ 下面介绍下一点点,它是一家饮品店.</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://wangjc95.com/post/2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 17 Feb 2019 17:34:00 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.观察者模式 1.1定义 观察者模式定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新.
1.2设计原则 为了交互对象之间的松耦合设计而努力.</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://wangjc95.com/post/1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 13 Feb 2019 21:30:48 +0800</pubDate>
      
      <guid>https://wangjc95.com/post/1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍: 这是阅读head first design patterns的阅读笔记.
1.应用场景 我们有一个鸭子模拟器,通过Duck父类表示鸭子的行为,子类通过重写display方法来表示鸭子的特征行为.现在有一个新需求,需要添加一个fly方法,让鸭子飞起来.
2.解决思路 2.1在父类中添加fly方法 RubberDuck无法飞行,所以需要重写fly方法.</description>
    </item>
    
  </channel>
</rss>